[0m[[0m[0minfo[0m] [0m[0m[32mArraySpec:[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: Arraylike objects should be able to implement IsArray[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: A 1d type that can implement IsArray, implements IsArray[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: A 2d 1dOf1d type that can implement IsArray, implements IsArray[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: A 2d list-of-list type that can implement IsArray, implements IsArray[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: Implicit class conversions and typeclass syntax for IsArray implementations[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: The user creates a valid arraylike and implements the typeclass; syntax should be available[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The Depth typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Depth has type Out of Nat 1 for a 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Depth has type Out of Nat 2 for a 2d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Depth has type Out of Nat 3 for a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The PrettyPrint typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Pretty printing a 1d array produces numpy-like output[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Pretty printing a 2d array produces numpy-like output[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Pretty printing a 3d array produces numpy-like output[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Pretty printing a 4d array produces numpy-like output[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The TransposeRT typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 2d array with (0, 1) correctly flips the axes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 3d array with (0, 1) correctly flips the axes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 3d array with (1, 2) correctly flips the axes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The TransposeFromListInt typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 2d array with List(1) returns None[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 2d array with List(1, 0) correctly flips the axes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 2d array with List(0, 1) does nothing[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 3d array with List(1, 0, 2) correctly transposes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 3d array with List(2, 0, 1) correctly transposes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 3d array with List(2, 1, 0) correctly transposes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 4d array with List(2, 1, 3, 0) correctly transposes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The TransposeUsingString typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 2d array with 'ac' returns None[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 4d array with List(2, 1, 3, 0) correctly transposes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The Transpose typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 2d array with AllSlice correctly flips the axes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 3d array with AllSlice correctly flips the axes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: transposing a 4d array with AllSlice correctly flips the axes[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Transposing a 2d array along axes 0/1 matches with numpy[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Transposing a 3d array along axes 0/1 matches with numpy[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Transposing a 3d array along axes 1/2 matches with numpy[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Transposing a 4d array along axes 2/3 matches with numpy[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Transposing a 3d array along 1/2 then 0/1 is the same as a full transpose[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Transposing a 4d array 0/1, 1/2, 2/3, 0/1, 1/2, 0/1 is the same as a full transpose[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The ConcatenateOpt typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Concatenating a 3d array along dimension 0 returns the correct result[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Concatenating a 3d array along dimension 1 returns the correct result[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Concatenating a 3d array along dimension 2 returns the correct result[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The AddOpt typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: adding a List1d to a List1d produces a combined array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: adding a List2d to a List2d returns a combined array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: adding a List2d to a List2d with different dim0 size returns a combined array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: adding a List2d to a List2d with different dim1 length returns None[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: adding a List3d to a List3d with dim1 and dim2 lengths the same returns a combined array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: adding a List3d to a List3d with different dim1 length returns None[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: MaskFromNumSeq typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: MaskDTFromNumSeq returns a correct mask for a 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: MaskFromNumSeq returns a correct mask for a 2d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: MaskFromNumSeq returns a correct mask for a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The Where typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Where with a 1d arraylike and a masking array returns a correct result[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Where with a 2d arraylike and a masking array returns a correct result[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Where with a 3d arraylike and a masking array returns a correct result[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Where with a 4d arraylike and a masking array returns a correct result[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The Reduce typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Using Reduce on a 1d arraylike does not compile[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Reducing a 2d arraylike across dim0 returns a correct 1d arraylike[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Reducing a 2d arraylike across dim1 returns a correct 1d arraylike[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Reducing a 3d arraylike across dim1 returns a correct 2d arraylike[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Reducing a 3d arraylike across dim2 returns a correct 2d arraylike[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: Multi-dimensional arrays[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: A value is returned from a 2d-dimensional array using getAtN[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m    Given A 1-dimensional arraylike, and a 2d list of 1d arraylike 2d array implementation [0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m    When getAtN is called on a concrete instance of the 2d arraylike [0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m    Then the returned value should be the 1d arraylike [0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: A value is returned from a 3d-dimensional array using getAtN[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m    Given A 3d arraylike [0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m    When getAtN is called on a concrete instance of the 3d arraylike [0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m    Then the returned value should be the 1d arraylike [0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: IsArray.getAtN[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: getAtN is called on a 1d Array to recover its original elements[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: IsArray.cons[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: IsArray objects are constructed from individual values using cons[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: IsArray.getEmpty[_T][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: .getEmpty[_T] is used on a 1d arraylike to create a new empty arraylike[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: .getEmpty[_T] is used  on a 2d arraylike to create a new empty arraylike[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The SubArrays typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: SubArrays.Out of a 1d array is an Hlist containing a 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: SubArrays.Out of a 2d array is an Hlist containing a 2d and a 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: SubArrays.Out of a 3d array is an Hlist containing a 3d, 2d and 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The ArraysSort typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Descending should witness a descending list of arrays[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Descending should not witness an ascending list of arrays[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Ascending should witness an ascending list of arrays[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Should not witness an disordered list of arrays[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The FromElemsAndSubArraysOpt typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List1d can be constructed from a list of Ts[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List2d can be constructed from a list of Ts[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List3d can be constructed from a list of Ts[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List1d can be constructed from a 2d array and a list of Ts[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List2d can be constructed from a 2d array and a list of Ts[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The FromElemsAndArrayOpt typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List1d can be constructed from a list of Ts[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List2d can be constructed from a list of Ts[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: IsArray.map[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: .map on a 1d array returns a mapped 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: .map on a 2d array returns a mapped 2d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: .map on a 3d array returns a mapped 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: .map double => char on a 3d array returns a mapped 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The ApplyIndex typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List[Int] is used to return the listed elements from a 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List[Int] :: HNil is used to return the listed elements from a 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a Int is used to return the listed elements from a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a Int :: HNil is used to return T from a 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a Int :: HNil is used to return a 2d from a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a Int :: List[Int] :: HNil is used to return a 2d from a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a Int :: Range :: HNil is used to return a 2d from a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: a List[Int] :: Int :: HNil is used to return a 2d from a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: an HList of List[Int] is used to return the correct elements from a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: an HList of List[Int] :: Int is used to return the correct elements from a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: apply with an HList of more elements than array dimensions will not compile[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: ApplyIndex with a boolean array of the same shape should return an appropriate List[T][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The IsArray.length method returns the length of the top dimension[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: An 1d array of y elements should return .length of y[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: A 2d array of y elements should return .length of y[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: A 3d array of y elements should return .length of y[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The Shape Typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: An 1d array of _ elements should return the correct shape[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: An 2d array of _ elements should return the correct shape[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: An 3d array of _ elements should return the correct shape[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The SetElem typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: setElem on dbl3d returns an updated array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The Flatten typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Flatten for a 1d array returns the correct List[T][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Flatten for a 2d array returns the correct List[T][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Flatten for a 3d array returns the correct List[T][0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The Operate typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Operate for two same-sized 1d arrays returns a correct 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Operate for two same-sized 3d arrays returns a correct 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Operate for two same-sized but different data 2d arrays returns a correct 2d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Operate for a multi-elem 1d arr and a single-elem 1d arr returns a correct 1d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Operate for a multi-elem 2d arr and a single-elem 2d arr returns a correct 2d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The ExpandShapeDims typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: ExpandShapeDims is used to convert a 2d shape into a 3d shape[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: ExpandShapeDims is used to convert a 1d shape into a 3d shape[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The ExpandDims typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Correctly inserting at dim0 into a 1d array creates a 2d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Correctly inserting at dim2 into a 1d array creates a 2d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Correctly inserting at dim1 into a 2d array creates a 3d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Correctly inserting at dim2 into a 3d array creates a 4d array[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The BroadcastShapesOpt typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Broadcasting shape from smaller to larger correctly[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Broadcasting from equal to equal correctly[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Broadcasting from smaller to larger incorrectly[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Broadcasting from equal to equal incorrectly[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32mFeature: The BroadcastOpt typeclass[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Broadcasting from 1d to 1d (1, L) correctly[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Broadcasting from 1d to 1d (L, 1) correctly[0m[0m
[0m[[0m[0minfo[0m] [0m[0m[32m  Scenario: Broadcasting from 2d to 3d (D0, D1, 1) correctly[0m[0m
